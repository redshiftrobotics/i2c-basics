doctype html
html
	head
		meta(charset='utf-8')
		meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
		title I2C basics

		link(rel='stylesheet', type='text/css', href='build/build.css')

	body

		article.language-clike

			section
				h1 I2C basics

			section
				h2 Why?

			section
				h2.bullet I2C: your new best friend
				h3.bullet I2C lets you more precisely control motors and servos
				h3.bullet It also lets you do PID, no strings attached
				h3.bullet You essentially get precise motor motion for free.

			section
				h2.bullet How does it work?
				h3.bullet Through the HiTechnic Motor Controller.
				h3.bullet You know, that little black box between your motor and your NXT.
				img.bullet(src='images/motorcontroller.png')

			section
				h2 What?

			section
				h2.bullet SAAS I2C Libraries - a tour
				h3.bullet Hosted on <a href="https://github.com/saasrobotics/libraries.git">GitHub</a>
				h3.bullet Embeddable in your projects via <a href="TODO">git submodules</a> - or plain old copy and paste, if not using git
				h3.bullet Layered architecture
				h3.bullet <a href="TODO">I2C.h</a> contains the base API
				<!-- TODO: revisit this. It will probably change soon. -->
				h3.bullet <a href="TODO">Motors.h</a> and <a href="TODO">Servos.h</a> are nice abstractions that work at the layer above <code>I2C.h</code>. Currently broken.

			section
				h2.bullet Let's look at the motor API
				h3.bullet Standardized format for all functions:
				h3.bullet
					<!-- behold the horror. screw you, Jade. -->
					pre
						code.
							void I2C_FooBar(tSensors port,
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int daisychainLevel,
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int motorNumber,
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbyte quux)

			section
				h2.bullet Variable format
				h3.bullet <code>FooBar</code> is the function name. These are generally pretty readable.
				h3.bullet <code>port</code> is one of <code>S1</code>, <code>S2</code>, <code>S3</code>, or <code>S4</code>.
				h3.bullet Daisychains start at 1, not 0.
				h3.bullet <code>quux</code> is a function-specific value (not always used).
				h3.bullet Internal methods are prefixed with <code>_</code>. Do not use them.

			section(data-bespoke-state='emphatic')
				h2.bullet Making a motor move
				pre.bullet
					code.
						#pragma config(Sensor, S4,     ,               sensorI2CCustom)
						/* while (true) loop because the motor controller times out
						after 2.5 seconds without a command */
						while (true)
						{
							/* set speed of motor 2, daisychain 3 on NXT port 4 to full (100) */ 
							I2C_SetMotorSpeed(S4, 3, 2, 100);
						}

			section
				h2.bullet That's it.

			section(data-bespoke-state='emphatic')
				h2.bullet Encoder tricks
				pre.bullet
					code.
						#pragma config(Sensor, S4,     ,               sensorI2CCustom)
						while (true)
						{
							/* on motor 2, daisychain 1 on NXT port 2, move to encoder position 200 */ 
							I2C_SetEncoderPosition(S2, 1, 2, 200);
						}

			section(data-bespoke-state='emphatic')
				h2.bullet Moar encoder tricks: let's get fancy
				pre.bullet
					code.
						#pragma config(Sensor, S4,     ,               sensorI2CCustom)
						while (true)
						{
							/* set speed of motor 1, daisychain 2 on NXT port 1, 
							move exactly a half rotation based on encoders */
							I2C_SetEncoderPosition(S1, 2, 1,
								I2C_GetEncoderPosition(S1, 2, 1) + 520);
						}

			section
				h2 That's still it.

			section
				h2.bullet Debugging
				h3.bullet Motors spinning at full speed? Check your encoders.
				h3.bullet Motors not spinning at all? Check your ports and power.
				h3.bullet Motors sometimes randomly spin the opposite direction? You're screwed. Don't use Motors.h or Servos.h. (Yet.)

			section
				h2 How?

			section
				h2.bullet Anatomy of an I2C write
				h3.bullet Every request is an array of bytes: a <code>tByteArray</code>
				h3.bullet Byte #1 specifies how many bytes will follow in the request (for a request of length <em>n</em> bytes byte #1 will be <em>n-1</em>). Required.
				h3.bullet Byte #2 specifies the address of the I2C device on the bus. Daisychain 1 is <code>0x02</code>, daisychain 2 is <code>0x04</code>, etc. Required.
				h3.bullet Byte #3 specifies the address on the motor controller register. Required.
				h3.bullet Byte #4 and above states the data to write to the register address. At least one required for a write.

			section(data-bespoke-state='emphatic')
				h2.bullet Setting motor speed
				pre
					code.
						tByteArray I2Crequest;
						/* three bytes of data follow the first byte */
						I2Crequest[0] = 3;

						/* device address on the I2C bus */
						I2Crequest[1] = 0x02 * daisychainLevel;

						/* 0x45 is the motor controller register address for motor 1 */
						I2Crequest[2] = 0x45;

						/* max speed is 100, max byte value is 255, so this will never overflow */
						I2Crequest[3] = Speed;

						writeI2C(port, I2Crequest);

			section
				h2.bullet Doing a read
				h3.bullet Just like doing a write, except that you don't pass any data in byte(s) 4+
				h3.bullet Instead, you pass (as arguments to <code>writeI2C()</code> a memory buffer to write a response to, and the length of the response

			section(data-bespoke-state='emphatic')
				h2 Talk is cheap; show me the code!
				pre
					code.
						tByteArray I2Crequest;
						/* this is the memory region that responses will get written to */
						tByteArray I2Cresponse;

						/* send 2 bytes */
						I2Crequest[0] = 2;

						/* send to daisychain 1 */
						I2Crequest[1] = 0x02;

						/* register address that, when read, returns the current encoder position of motor 1 */
						I2Crequest[2] = 0x4C;

						/* sends the read and writes a 4-byte response into I2Cresponse */
						writeI2C(port, I2Crequest, I2Cresponse, 4);

			section
				h2.bullet Breaking up the bytes
				h3.bullet You can't just send a <code>long</code> or an <code>int</code>
				h3.bullet You have to break it up into individual bytes
				h3.bullet You do this with bitshifting and masking

			section
				h2.bullet Bitshifting
				h3.bullet In a memory buffer, bitshifting shifts a certain number of bits to either the left or the right
				h3.bullet Essentially, it truncates either the left or the right
				h3.bullet However, this pulls in garbage on the other side
				h3.bullet You use masking to reset the garbage to all 0s

			section
				h2 Formatting for write
				pre
					code.
						tByteArray I2Crequest2;
						I2Crequest2[0] = 6;
						I2Crequest2[1] = 0x02 * daisychainLevel;
						I2Crequest2[2] = 0x48;
						I2Crequest2[3] = (byte)((EncoderPosition >> 24) & 0x000000ff);
						I2Crequest2[4] = (byte)((EncoderPosition >> 16) & 0x000000ff);
						I2Crequest2[5] = (byte)((EncoderPosition >> 8) & 0x000000ff);
						I2Crequest2[6] = (byte)(EncoderPosition & 0x000000ff);
						writeI2C(port, I2Crequest2);

			section
				h2.bullet Potential gotchas
				h3.bullet The order for power and mode is switched for motor 1 and motor 2
				h3.bullet <code>daisychain--</code>: this is to do some nice math instead of using an awful <code>switch</code> statement


		script(src='build/build.js')

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>I2C basics</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article class="language-clike">
      <section>
        <h1>I2C basics</h1>
      </section>
      <section>
        <h2>Why?</h2>
      </section>
      <section>
        <h2 class="bullet">I2C: your new best friend</h2>
        <h3 class="bullet">I2C lets you more precisely control motors and servos</h3>
        <h3 class="bullet">It also lets you do PID, no strings attached</h3>
        <h3 class="bullet">You essentially get precise motor motion for free.</h3>
      </section>
      <section>
        <h2 class="bullet">How does it work?</h2>
        <h3 class="bullet">Through the HiTechnic Motor Controller.</h3>
        <h3 class="bullet">You know, that little black box between your motor and your NXT.</h3><img src="images/motorcontroller.png" class="bullet">
      </section>
      <section>
        <h2>What?</h2>
      </section>
      <section>
        <h2 class="bullet">SAAS I2C Libraries - a tour</h2>
        <h3 class="bullet">Hosted on <a href="https://github.com/saasrobotics/libraries.git">GitHub</a></h3>
        <h3 class="bullet">Embeddable in your projects via <a href="TODO">git submodules</a> - or plain old copy and paste, if not using git</h3>
        <h3 class="bullet">Layered architecture</h3>
        <h3 class="bullet"><a href="TODO">I2C.h</a> contains the base API</h3><!-- TODO: revisit this. It will probably change soon. -->
        <h3 class="bullet"><a href="TODO">Motors.h</a> and <a href="TODO">Servos.h</a> are nice abstractions that work at the layer above <code>I2C.h</code>. Currently broken.</h3>
      </section>
      <section>
        <h2 class="bullet">Let's look at the motor API</h2>
        <h3 class="bullet">Standardized format for all functions:</h3>
        <h3 class="bullet"><!-- behold the horror. screw you, Jade. -->
          <pre><code>void I2C_FooBar(tSensors port,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int daisychainLevel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int motorNumber,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbyte quux)
</code></pre>
        </h3>
      </section>
      <section>
        <h2 class="bullet">Variable format</h2>
        <h3 class="bullet"><code>FooBar</code> is the function name. These are generally pretty readable.</h3>
        <h3 class="bullet"><code>port</code> is one of <code>S1</code>, <code>S2</code>, <code>S3</code>, or <code>S4</code>.</h3>
        <h3 class="bullet">Daisychains start at 1, not 0.</h3>
        <h3 class="bullet"><code>quux</code> is a function-specific value (not always used).</h3>
        <h3 class="bullet">Internal methods are prefixed with <code>_</code>. Do not use them.</h3>
      </section>
      <section data-bespoke-state="emphatic">
        <h2 class="bullet">Making a motor move</h2>
        <pre class="bullet"><code>#pragma config(Sensor, S4,     ,               sensorI2CCustom)
/* while (true) loop because the motor controller times out
after 2.5 seconds without a command */
while (true)
{
 /* set speed of motor 2, daisychain 3 on NXT port 4 to full (100) */ 
 I2C_SetMotorSpeed(S4, 3, 2, 100);
}
</code></pre>
      </section>
      <section>
        <h2 class="bullet">That's it.</h2>
      </section>
      <section data-bespoke-state="emphatic">
        <h2 class="bullet">Encoder tricks</h2>
        <pre class="bullet"><code>#pragma config(Sensor, S4,     ,               sensorI2CCustom)
while (true)
{
 /* on motor 2, daisychain 1 on NXT port 2, move to encoder position 200 */ 
 I2C_SetEncoderPosition(S2, 1, 2, 200);
}
</code></pre>
      </section>
      <section data-bespoke-state="emphatic">
        <h2 class="bullet">Moar encoder tricks: let's get fancy</h2>
        <pre class="bullet"><code>#pragma config(Sensor, S4,     ,               sensorI2CCustom)
while (true)
{
 /* set speed of motor 1, daisychain 2 on NXT port 1, 
 move exactly a half rotation based on encoders */
 I2C_SetEncoderPosition(S1, 2, 1,
  I2C_GetEncoderPosition(S1, 2, 1) + 520);
}
</code></pre>
      </section>
      <section>
        <h2>That's still it.</h2>
      </section>
      <section>
        <h2 class="bullet">Debugging</h2>
        <h3 class="bullet">Motors spinning at full speed? Check your encoders.</h3>
        <h3 class="bullet">Motors not spinning at all? Check your ports and power.</h3>
        <h3 class="bullet">Motors sometimes randomly spin the opposite direction? You're screwed. Don't use Motors.h or Servos.h. (Yet.)</h3>
      </section>
      <section>
        <h2>How?</h2>
      </section>
      <section>
        <h2 class="bullet">Anatomy of an I2C write</h2>
        <h3 class="bullet">Every request is an array of bytes: a <code>tByteArray</code></h3>
        <h3 class="bullet">Byte #1 specifies how many bytes will follow in the request (for a request of length <em>n</em> bytes byte #1 will be <em>n-1</em>). Required.</h3>
        <h3 class="bullet">Byte #2 specifies the address of the I2C device on the bus. Daisychain 1 is <code>0x02</code>, daisychain 2 is <code>0x04</code>, etc. Required.</h3>
        <h3 class="bullet">Byte #3 specifies the address on the motor controller register. Required.</h3>
        <h3 class="bullet">Byte #4 and above states the data to write to the register address. At least one required for a write.</h3>
      </section>
      <section data-bespoke-state="emphatic">
        <h2 class="bullet">Setting motor speed</h2>
        <pre><code>tByteArray I2Crequest;
/* three bytes of data follow the first byte */
I2Crequest[0] = 3;

/* device address on the I2C bus */
I2Crequest[1] = 0x02 * daisychainLevel;

/* 0x45 is the motor controller register address for motor 1 */
I2Crequest[2] = 0x45;

/* max speed is 100, max byte value is 255, so this will never overflow */
I2Crequest[3] = Speed;

writeI2C(port, I2Crequest);
</code></pre>
      </section>
      <section>
        <h2 class="bullet">Doing a read</h2>
        <h3 class="bullet">Just like doing a write, except that you don't pass any data in byte(s) 4+</h3>
        <h3 class="bullet">Instead, you pass (as arguments to <code>writeI2C()</code> a memory buffer to write a response to, and the length of the response</h3>
      </section>
      <section data-bespoke-state="emphatic">
        <h2>Talk is cheap; show me the code!</h2>
        <pre><code>tByteArray I2Crequest;
/* this is the memory region that responses will get written to */
tByteArray I2Cresponse;

/* send 2 bytes */
I2Crequest[0] = 2;

/* send to daisychain 1 */
I2Crequest[1] = 0x02;

/* register address that, when read, returns the current encoder position of motor 1 */
I2Crequest[2] = 0x4C;

/* sends the read and writes a 4-byte response into I2Cresponse */
writeI2C(port, I2Crequest, I2Cresponse, 4);
</code></pre>
      </section>
      <section>
        <h2 class="bullet">Breaking up the bytes</h2>
        <h3 class="bullet">You can't just send a <code>long</code> or an <code>int</code></h3>
        <h3 class="bullet">You have to break it up into individual bytes</h3>
        <h3 class="bullet">You do this with bitshifting and masking</h3>
      </section>
      <section>
        <h2 class="bullet">Bitshifting</h2>
        <h3 class="bullet">In a memory buffer, bitshifting shifts a certain number of bits to either the left or the right</h3>
        <h3 class="bullet">Essentially, it truncates either the left or the right</h3>
        <h3 class="bullet">However, this pulls in garbage on the other side</h3>
        <h3 class="bullet">You use masking to reset the garbage to all 0s</h3>
      </section>
      <section>
        <h2>Formatting for write</h2>
        <pre><code>tByteArray I2Crequest2;
I2Crequest2[0] = 6;
I2Crequest2[1] = 0x02 * daisychainLevel;
I2Crequest2[2] = 0x48;
I2Crequest2[3] = (byte)((EncoderPosition >> 24) & 0x000000ff);
I2Crequest2[4] = (byte)((EncoderPosition >> 16) & 0x000000ff);
I2Crequest2[5] = (byte)((EncoderPosition >> 8) & 0x000000ff);
I2Crequest2[6] = (byte)(EncoderPosition & 0x000000ff);
writeI2C(port, I2Crequest2);
</code></pre>
      </section>
      <section>
        <h2 class="bullet">Potential gotchas</h2>
        <h3 class="bullet">The order for power and mode is switched for motor 1 and motor 2</h3>
        <h3 class="bullet"><code>daisychain--</code>: this is to do some nice math instead of using an awful <code>switch</code> statement</h3>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>